// Code generated by "go run compress_generate.go"; DO NOT EDIT.

package dns

func compressionLenHelperType(c map[string]int, r RR, currentLen int) {
	switch x := r.(type) {
	case *AFSDB:
		compressionLenHelper(c, x.Hostname, currentLen)
	case *CNAME:
		compressionLenHelper(c, x.Target, currentLen)
	case *DNAME:
		compressionLenHelper(c, x.Target, currentLen)
	case *HIP:
		for i := range x.RendezvousServers {
			compressionLenHelper(c, x.RendezvousServers[i], currentLen)
		}
	case *KX:
		compressionLenHelper(c, x.Exchanger, currentLen)
	case *LP:
		compressionLenHelper(c, x.Fqdn, currentLen)
	case *MB:
		compressionLenHelper(c, x.Mb, currentLen)
	case *MD:
		compressionLenHelper(c, x.Md, currentLen)
	case *MF:
		compressionLenHelper(c, x.Mf, currentLen)
	case *MG:
		compressionLenHelper(c, x.Mg, currentLen)
	case *MINFO:
		compressionLenHelper(c, x.Rmail, currentLen)
		compressionLenHelper(c, x.Email, currentLen)
	case *MR:
		compressionLenHelper(c, x.Mr, currentLen)
	case *MX:
		compressionLenHelper(c, x.Mx, currentLen)
	case *NAPTR:
		compressionLenHelper(c, x.Replacement, currentLen)
	case *NS:
		compressionLenHelper(c, x.Ns, currentLen)
	case *NSAPPTR:
		compressionLenHelper(c, x.Ptr, currentLen)
	case *NSEC:
		compressionLenHelper(c, x.NextDomain, currentLen)
	case *PTR:
		compressionLenHelper(c, x.Ptr, currentLen)
	case *PX:
		compressionLenHelper(c, x.Map822, currentLen)
		compressionLenHelper(c, x.Mapx400, currentLen)
	case *RP:
		compressionLenHelper(c, x.Mbox, currentLen)
		compressionLenHelper(c, x.Txt, currentLen)
	case *RRSIG:
		compressionLenHelper(c, x.SignerName, currentLen)
	case *RT:
		compressionLenHelper(c, x.Host, currentLen)
	case *SIG:
		compressionLenHelper(c, x.SignerName, currentLen)
	case *SOA:
		compressionLenHelper(c, x.Ns, currentLen)
		compressionLenHelper(c, x.Mbox, currentLen)
	case *SRV:
		compressionLenHelper(c, x.Target, currentLen)
	case *TALINK:
		compressionLenHelper(c, x.PreviousName, currentLen)
		compressionLenHelper(c, x.NextName, currentLen)
	case *TKEY:
		compressionLenHelper(c, x.Algorithm, currentLen)
	case *TSIG:
		compressionLenHelper(c, x.Algorithm, currentLen)
	}
}

func compressionLenSearchType(c map[string]int, r RR) (int, bool) {
	switch x := r.(type) {
	case *AFSDB:
		k1, ok1 := compressionLenSearch(c, x.Hostname)
		return k1, ok1
	case *CNAME:
		k1, ok1 := compressionLenSearch(c, x.Target)
		return k1, ok1
	case *MB:
		k1, ok1 := compressionLenSearch(c, x.Mb)
		return k1, ok1
	case *MD:
		k1, ok1 := compressionLenSearch(c, x.Md)
		return k1, ok1
	case *MF:
		k1, ok1 := compressionLenSearch(c, x.Mf)
		return k1, ok1
	case *MG:
		k1, ok1 := compressionLenSearch(c, x.Mg)
		return k1, ok1
	case *MINFO:
		k1, ok1 := compressionLenSearch(c, x.Rmail)
		k2, ok2 := compressionLenSearch(c, x.Email)
		return k1 + k2, ok1 && ok2
	case *MR:
		k1, ok1 := compressionLenSearch(c, x.Mr)
		return k1, ok1
	case *MX:
		k1, ok1 := compressionLenSearch(c, x.Mx)
		return k1, ok1
	case *NS:
		k1, ok1 := compressionLenSearch(c, x.Ns)
		return k1, ok1
	case *PTR:
		k1, ok1 := compressionLenSearch(c, x.Ptr)
		return k1, ok1
	case *RT:
		k1, ok1 := compressionLenSearch(c, x.Host)
		return k1, ok1
	case *SOA:
		k1, ok1 := compressionLenSearch(c, x.Ns)
		k2, ok2 := compressionLenSearch(c, x.Mbox)
		return k1 + k2, ok1 && ok2
	}
	return 0, false
}
